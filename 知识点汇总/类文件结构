## 1.Class类文件的结构

​		Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，只有两种数据类型：无符号数（属于基本的数据类型，以u1,u2,u4,u8代表1、2、4、8个字节的无符号数，可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成的字符串值）和表（由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“info”结尾，可以用来描述有层次关系的复合结构的数据），整个Class文件本质上就是一张表。

* **魔数与Class文件的版本**：头4个字节为魔数（0xCAFEBABE），第5第6个字节为次版本号，第7第8个字节为主版本号。
* **常量池**：紧接着主次版本号之后的是常量池入口，可以理解为Class文件的资源仓库。常量池中常量个数不固定，入口放置一项u2类型的数据代表容量计数值（从1开始计数，总值-1为常量个数）。主要存放两大类常量：字面量和符号引用。常量池中每项常量都是一个表，表的第一位是一个u1类型的标志位，代表当前常量属于哪种常量类型。
* **访问标志**：常量池结束后，紧接着两个字节代表访问标志，用于识别一些类或接口层次的访问信息，包括Class是类还是接口，是否定义为public，是否定义为abstract；如果是类的话，是否被声明为final等。
* **类索引、父类索引与接口索引集合**：按顺序排列在访问标记之后。类索引和父类索引都是一个u2类型的数据，而接口索引集合是一组u2类型的数据的集合，Class文件中由这3项数据来确定这个类的继承关系。类索引：确定这个类的全限定名。父类索引：确定这个类的父类的全限定名。接口索引集合：描述这个类实现了哪些接口，这些被实现的接口将按照implements语句后的接口顺序从左到右排列在接口索引集合中。
* **字段表索引集合**：用于描述接口或者类中声明的变量：包括类级变量和实例级变量，但不包括在方法内部声明的局部变量。描述字段的信息：作用域、实例还是类变量修饰符、可变性、并发可见性、是否被序列化、字段数据类型、字段名称。字段表结构：access_flag, name_index, description_index（字段修饰符、简单名称索引、描述符（描述字段的数据类型、方法的参数列表如[[Ljava/lang/String））。
* **方法表集合**：对方法的描述，结构和字段类似。依次包括：访问标志、名称索引、描述符索引、属性表索引。如果父类方法在子类中没有被重写，方法表集合中就不会出现来自父类的方法信息。要重载一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名（指一个方法中各个参数在常量池中的字段符号引用的集合，但返回值不包含在特征签名中，因此Java语言无法仅仅通过返回值的不同对一个方法进行重载。而在Class文件格式中，返回值不同是可以合法并存在一个Class文件中，因为字节码的特征签名还包括方法返回值和受查差异表）。
* **属性表集合**：在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。
  * Code属性：Java程序方法体的代码被编译我字节码指令存储在Code属性中。max_stack代表操作数栈深度最大值，虚拟机分配栈帧中的操作栈深度。max_locals代表局部变量表所需存储空间，单位Slot。编译器根据变量作用域分配Slot（可重用）给各个变量使用，然后计算max_locals。code用来存储编译后的字节码指令，每条指令占用一个u1单字节，共可表达256条指令（虚拟机规范依据定义了约200条编码值对应的指令含义）。code_length是code的长度，是一个u4长度值，理论可达到2³²-1，但虚拟机规范明确限制一个方法不超过65535条字节码指令，即只使用了u2的长度，如果超过限制javac编译器将拒绝编译。    在字节码指令后世这个方法的显式异常处理表。
  * Exception属性：列举出方法中可能抛出的受查异常，也就是方法描述时在throws关键字后列举的异常。
  * LineNumberTable属性：描述Java源码行号和字节码行号（字节码的偏移量）之间的对应关系。
  * LocalVariableTable属性：描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系。
  * SourceFile属性：记录生成这个Class文件的源码文件名称。
  * ConstantValue属性：通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量才可以使用这项属性。（如果同时使用final和static修饰变量且数据类型为基本类型或String，就生成ConstantValue属性来进行初始化，否则选择<clinit>方法中进行初始化）
  * InnerClasses属性：记录内部类与宿主类之间的关联。如果一个类定义了内部类，那么编译器将会为它所包含的内部类生成InnerClasses属性。
  * Deprecated及Synthetic属性：属于标志类型的布尔属性，只存在有和没有的区别。Deprecated表示某个类、字段或方法已经被程序作者定为不再推荐使用，可通过注解进行设置；Synthetic代表此字段或方法不是Java源码产生的，而是由编译器自行添加的。
  * StackMapTable属性：JDK1.6后增加的，是一个复杂的变长属性，位于Code属性的属性表中。
  * Signature属性：任何类、接口、初始化方法或者成员的泛型签名如果包含了类型变量或参数化类型，则Sugnature属性会为它记录泛型签名信息。因为Java泛型采用的是擦除法实现的伪泛型，在字节码中，泛型信息编译之后都统统被擦除掉。使用擦除法好处是实现简单，运行期能够节省一些类型所占的内存空间。坏处是运行期无法支持真泛型。Signature属性为了弥补这个缺陷，现在Java反射API能够获取泛型类型，最终的数据来源也就是这个属性。
  * BootstrapMethods属性：用于保存invokedynamic指令引用的引导方法限定符。如果类文件结构的常量池中曾经出现过CONSTANT_InvokeDynamic_info类型的常量，那么属性表必须存在一个明确的BootstrapMethods属性。

## 2.字节码指令

​		Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数Operands）而构成。由于Java虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数的指令只有一个操作码。Java虚拟机操作码长度为1字节，意味着总操作数不可能超过256条。

* 字节码与数据类型：大多数指令都包含了其操作所对应的数据烈性信息。
* 加载和存储指令：将数据在栈帧的局部变量表和操作数栈之间来回传输。
* 运算指令：用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。
* 类型转换指令：可以将两种不同的数值类型进行互相转换，这些转换操作一般用于实现用户代码中的显式类型转换操作。
* 对象创建与访问指令：类实例和数组都是对象，但创建和操作使用了不同的字节码指令。
* 操作数栈管理指令：用于直接操作操作数栈的指令，如同操作一个普通数据结构中的堆栈那样。
* 控制转移指令：可以让虚拟机有条件或无条件从指定的位置指令而不受控制转移指令的下一条指令继续执行程序。
* 方法调用和返回指令：分派、执行过程。
* 异常处理指令：显式抛出异常的操作都是athrow指令来实现。
* 同步指令：可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是采用管程（Monitor）来支持的。方法级的同步是隐式的，无须通过字节码指令来控制（各级方法的ACC_SYNCHRONIZED访问标志判断是否需要同步，如果设置了，执行线程就要求先成功持有管程）。指令级序列通常有synchronized语句块表示，指令集中有monitorenter和monitorexit两条指令来支持该关键字的语义。