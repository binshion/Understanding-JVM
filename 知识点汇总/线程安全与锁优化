## 1.线程安全

​		当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。

​		线程安全的实现方法

* 互斥同步（Mutual Exclusion & Synchronization）：是常见的一种并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。因此互斥是因，同步是果，互斥是方法，同步是目的。Java中最基本的互斥同步手段是synchronized关键字，经过编译之后会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象（没有明确指定时，根据修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象）。同步块在已进入的线程执行完之前会阻塞后面其他线程的进入，而java的线程是映射到操作系统的原生线程之上的，所以唤醒或阻塞一个线程都需要操作系统来帮忙完成，这就需要从用户态转换到内核态中，这将耗费很多的处理器时间，所以synchronized是一个重量级的操作。除了synchronized之外，还有J.U.C包中的重入锁ReentrantLock来实现同步，增加了一些高级功能：
  * 等待可中断：持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。
  * 公平锁：按照申请锁的时间顺序来依次获得锁（默认情况也是非公平的，可以通过带布尔值得构造函数要求使用公平锁）。
  * 锁绑定多个条件：ReentrantLock对象可以同时绑定多个Condition对象。
* 非阻塞同步（Non-Blocking Synchronization）：互斥同步最主要的问题是线程阻塞和唤醒带来的性能问题，因此也称为阻塞同步（Blocking Synchronization）。从处理问题的方式上说互斥同步是一种悲观的并发策略。随着硬件指令集（需要操作和冲突检测这两个步骤具有原子性，即硬件保证多次操作的行为只通过一条处理器指令就能完成，常用的有测试并设置、获取并增加、交换、比较并交换等）的发展，有了基于冲突检测的乐观并发策略（先进行操作，如果没有其他线程争用共享数据，那操作就成功，否则产生了冲突再采取其他的补偿措施如不断重试直到成功为止），这种乐观的并发策略的许多实现都不需要将线程挂起，因此这种同步操作也称为非阻塞同步。CAS指令需要3个操作数，内存位置（变量的内存地址），旧的预期值和新值，CAS指令执行时，当且仅当内存位置符合旧的预期值时，处理器用新值更新内存位置的值，否则它就不执行更新，但是无论是否更新了内存位置的值，都会返回内存位置的旧值。
* 无同步方案：
  * 可重入代码：不依赖存储在堆上的数据和公用的系统资源、用到的状态量都是有参数中传入、不调用非重入的方法等。
  * 线程本地存储（Thread Local Storage）：把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现争用的问题。一个变量要被多线程访问，可以使用volatile关键字声明为易变得，如果一个变量要被某个线程独享，可以通过ThreadLocal类来实现线程的本地存储。每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值得键值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口。

## 2.锁优化

