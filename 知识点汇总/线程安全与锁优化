## 1.线程安全

​		当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。

​		线程安全的实现方法

* 互斥同步（Mutual Exclusion & Synchronization）：是常见的一种并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。因此互斥是因，同步是果，互斥是方法，同步是目的。Java中最基本的互斥同步手段是synchronized关键字，经过编译之后会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象（没有明确指定时，根据修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象）。同步块在已进入的线程执行完之前会阻塞后面其他线程的进入，而java的线程是映射到操作系统的原生线程之上的，所以唤醒或阻塞一个线程都需要操作系统来帮忙完成，这就需要从用户态转换到内核态中，这将耗费很多的处理器时间，所以synchronized是一个重量级的操作。除了synchronized之外，还有J.U.C包中的重入锁ReentrantLock来实现同步，增加了一些高级功能：
  * 等待可中断：持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。
  * 公平锁：按照申请锁的时间顺序来依次获得锁（默认情况也是非公平的，可以通过带布尔值得构造函数要求使用公平锁）。
  * 锁绑定多个条件：ReentrantLock对象可以同时绑定多个Condition对象。
* 非阻塞同步（Non-Blocking Synchronization）：互斥同步最主要的问题是线程阻塞和唤醒带来的性能问题，因此也称为阻塞同步（Blocking Synchronization）。从处理问题的方式上说互斥同步是一种悲观的并发策略。随着硬件指令集（需要操作和冲突检测这两个步骤具有原子性，即硬件保证多次操作的行为只通过一条处理器指令就能完成，常用的有测试并设置、获取并增加、交换、比较并交换等）的发展，有了基于冲突检测的乐观并发策略（先进行操作，如果没有其他线程争用共享数据，那操作就成功，否则产生了冲突再采取其他的补偿措施如不断重试直到成功为止），这种乐观的并发策略的许多实现都不需要将线程挂起，因此这种同步操作也称为非阻塞同步。CAS指令需要3个操作数，内存位置（变量的内存地址），旧的预期值和新值，CAS指令执行时，当且仅当内存位置符合旧的预期值时，处理器用新值更新内存位置的值，否则它就不执行更新，但是无论是否更新了内存位置的值，都会返回内存位置的旧值。
* 无同步方案：
  * 可重入代码：不依赖存储在堆上的数据和公用的系统资源、用到的状态量都是有参数中传入、不调用非重入的方法等。
  * 线程本地存储（Thread Local Storage）：把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现争用的问题。一个变量要被多线程访问，可以使用volatile关键字声明为易变得，如果一个变量要被某个线程独享，可以通过ThreadLocal类来实现线程的本地存储。每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值得键值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口。

## 2.锁优化

​		高效并发是从1.5到1.6的一个重要改进，花费了大量的精力去实现各种锁优化技术，如适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等等，这些技术都是为了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。

* 自旋锁和自适应自旋：为了避免互斥同步挂起线程和恢复线程进行的用户态和内核态的转换，如果物理机器有一个以上的处理器，能让一个以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，只需要让线程执行一个忙循环（自旋），这项技术就是自旋锁。自旋等待本身虽然避免了线程切换的开销，但是会占用处理器的时间。如果锁被占用的时间很短，那么自旋等待的效果会非常好。自适应意味着自旋的时间不再固定，而是由前一次在同一个锁上的自旋时间和锁的拥有者状态来决定。
* 锁消除：虚拟机即时编译器在运行时，对一些代码上要求同步，但被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判断依据来源于逃逸分析的数据支持（分析对象的作用域，不会逃逸的变量可以进行一些高效优化如栈上分配、同步消除、标量替换），如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那可以把它们当做栈上数据对待，认为是线程私有的，同步加锁自然就无须进行。
* 锁粗化：原则上推荐将同步块的作用范围限制得尽可能小，只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，等待锁的线程也能尽快拿到锁。但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。如果虚拟机探测到右这样的一串零碎的操作都对一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，这样只需要加一次锁就可以了。
* 轻量级锁：在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。对象的对象头内存布局分为两部分信息，第一部分用于存储对象自身的运行数据，如哈希码、GC分代年龄等，长度为32和64位（32位和64位虚拟机分别这么分配，官方称它为“Mark Word”，32位虚拟机对象32bit空间中25bit用于存储对象哈希码，4bit存储分代年龄，2bit存储锁标志位（01未锁定，00轻量级锁定，10膨胀（重量级锁定），11 GC标记，01可偏向根据存储内容确定），1bit固定为0）,它是实现轻量级锁和偏向锁的关键。另一部分用于存储指向方法区对象类型数据的指针，数组对象还有额外的部分用于存储数组长度。加锁过程：代码进入同步块时如果对象未被锁定（01状态），虚拟机首先在当前线程的栈帧中建立一个名为锁记录的空间，存储对象的Mark Word拷贝，然后虚拟机使用CAS操作尝试将对象的Mark Word更新为指向锁记录的指针。如果更新动作成功了，那么线程就拥有了该对象的锁，并且对象的锁标志位转变为00处于轻量级锁定状态。如果更新失败了，首先检查对象的Mark Word是否指向当前线程的栈帧，如果是说明当前线程已经拥有对象的锁，可直接进入同步块，否则说明这个锁对象已经被其他线程抢占了。如果有两条以上的线程争用一个锁，那轻量级锁要膨胀为重量级锁，标志位变为10，mark word中存储的指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。解锁过程：如果对象的mark word仍然指向这线程的锁记录，那用CAS操作把对象当前的mark word和线程中复制的displaced mark word替换回来，如果替换成功，整个同步过程就完成；如果替换失败，说明有其他线程尝试过获取该锁，那么在释放锁的同时，唤醒被挂起的线程。
* 偏向锁：JDK 1.6引入的一项锁优化，目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。偏向锁会偏向于第一个获得它的想线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。假设当前虚拟机启用了偏向锁（启用参数-XX:+UseBiasedLocking，这是jdk1.6的默认值），那么，当锁对象第一次被线程获取的时候，虚拟机将对象头的标志位设置为01偏向模式，同时使用CAS操作把获取到这个锁的线程id记录在对象的mark word中，如果CAS操作成功了，持有偏向锁的线程以后每次进入这个锁相关的同步块，虚拟机都可以不再进行任何同步操作。当有另外一个线程去尝试获得这个锁时，偏向模式就宣告失败。根据锁对象目前是否处于被锁定的状态，撤销偏向后恢复到未锁定01或轻量级锁定00状态，后续的同步操作就如同轻量级锁那样执行。偏向锁可以提高带有同步但无竞争的程序性能，如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的。有时候使用参数-XX:-UseBiasedLocking来进制偏向锁优化反而可以提升性能。