* 哪些内存需要回收？
* 什么时候回收？
* 如何回收？

## 1.哪些内存需要回收

​		Java内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出执行着出栈和入栈操作。每个栈帧中分配多少内存基本上在类结构确定下来时就已知，因此这几个区域的内存分配和回收具备确定性，不需要过多考虑回收的问题，因为方法结束或县城结束时，内存自然就跟随回收了。而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法的多个分支需要的内存也不一样，我们只有在程序处于运行期才知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这个部分的内存。

## 2.什么时候回收

* **引用计数算法**：<u>（常规答复）</u>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加1；当引用失效时，计数器值减1；任何时刻计数器为0的对象就是不可能再被使用的。**但是，至少主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间互相循环引用的问题。**

* **可达性分析算法**：通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。

  可作为GC Roots的对象包括：

  * 虚拟机栈（栈帧中的本地变量表）中引用的对象
  * 方法区中类静态属性引用的对象
  * 方法区中常量引用的对象
  * 本地方法栈中JNI（即一般说的Native方法）引用的对象
  
* 再谈引用：当内存空间还足够时，则能保存在内存之中；如果内存空间在垃圾收集后还是非常紧张，则可以抛弃这些对象。

  * 强引用：普遍存在，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
  * 软引用：描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。
  * 弱引用：描述非必需的对象，但它的强度比软引用更弱一些，被软引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉被弱引用关联的对象。
  * 虚引用：也成为幽灵引用或幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。
  
* 生存还是死亡：可达性分析算出的不可达对象，要真正宣告一个对象死亡，至少要经历两次标记过程：

  * 第一次标记：可达性分析对象不可达时，将被第一次标记并且进行一次筛选，筛选条件：此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法或者finalize()方法已经被虚拟机调用过，视为“没有必要执行”。
  * 第二次标记：对象被判定有必要执行finalize()方法，那么对象架构被放置到一个叫做F-Queue的队列中，稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。finalize()方法是对象逃脱死亡的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己（重新与引用链上的任何一个对象建立关联，如把自己赋值给某个类变量或对象的成员变量），那么第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没逃脱，那基本上要真的被回收了。

## 3.如何回收