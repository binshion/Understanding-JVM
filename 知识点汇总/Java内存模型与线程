## 1.Java内存模型

​		主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和内存中取出变量这样的底层细节。Java内存模型规定所有的变量都存储在主内存，每条线程都有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中今夕，而不能直接读取主内存中的变量。

* 内存间交互操作
  * lock锁定
  * unlock解锁
  * read读取
  * load载入
  * use使用
  * assign赋值
  * store存储
  * write写入
* 对于volitile型变量的特殊规则：原理-volatile修饰的共享变量在进行写操作的时候会多一行汇编代码，luck前缀指令在多核处理器下引发两件事情：将当前处理器缓存行的数据写回到系统内存（声言该信号期间，处理器可以独占使用任何共享内存，锁总线，其他CPU不能访问总线）；这个写回内存的操作会引起其他CPU里缓存了该内存地址的数据无效（缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己的缓存的值是否过期，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态。 MESI（修改，独占，共享，无效）控制协议去维护内部缓存和其他处理器缓存的一致性。在多核处理器系统中进行操作的时候，IA-32 和 Intel 64 处理器能嗅探其他处理器访问系统内存和它们的内部缓存。它们使用嗅探技术保证它的内部缓存，系统内存和其他处理器的缓存的数据在总线上保持一致。）。
  * 特性1：保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。由于volatile变量只能保证可见性，我们可能需要通过加锁来保证原子性。
  * 特性2：禁止指令重排序优化。（指令重排序是指CPU采用了允许将多条指令不安程序规定的顺序分开发送给各相应电路管理单元处理）
* happens-before先行发生原则：Java内存模型中定义的两项操作之间的偏序关系。Java内存模型下一些“天然的”先行发生关系，这些无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。
  * 程序次序规则：在一个线程内，安装程序代码顺序，书写在前的操作先行发生于书写在后面的操作（准确的说是控制流顺序而不是代码顺序）。
  * 管程锁定规则：一个unlock操作先行发生于后面（时间上的顺序）对同一个锁的lock操作。
  * volatile变量规则：对同一个volatile变量的写操作先行发生于后面（时间上的顺序）对这个变量的读操作。
  * 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。
  * 线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，可以通过join()方法结束和isAlive()的返回值等手段检测到线程已经终止执行。
  * 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过interrupted()方法检测到是否有中断发生。
  * 对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法。
  * 传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C。

## 2.线程

​		线程是比进程更轻量级的调度执行单位，线程的引入，可以把衣蛾进程的资源分配和执行调度分开，各个线程既可以共享进程资源，又可以独立调度（线程是CPU调度的基本单位）。

​		实现线程的3种方式：

* 使用内核线程实现：直接由操作系统内核支持的线程，由内核来完成线程切换，内核通过操纵调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口——轻量级进程，每个轻量级进程都是由一个内核线程支持。一对一线程模型。

* 使用用户线程实现：广义上——一个线程只要不是内核线程，就可以认为是用户线程。狭义上——完全建立在用户控件的线程库上，系统内核不能感知线程存在的实现。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。一对多线程模型。

* 使用用户线程加轻量级进程混合实现：N ：M

* Java线程的实现：操作系统支持怎样的线程模型，很大程度决定了Java虚拟机的线程是怎样映射的。对于Sun JDK来说，Win和Linux版都是使用一对一的线程模型实现的。而在Solaris平台中支持一对一和多对多线程模型，所以Solaris版的JDK对应提供专有虚拟机参数来明确指定虚拟机使用哪种线程模型（默认是多对多）。

Java线程调度：指系统为线程分配处理器使用权的过程，两种主要调度方式：

* 协同式线程调度：线程本身控制线程的执行时间，线程把自己的工作执行完了之后，要主动童子系统切换到另外一个线程上。缺点：线程执行时间不可控制，如果线程编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞。

* 抢占式线程调度：系统来分配执行时间，线程的切换不由线程本身来决定（Thread.yield()可以让出执行时间，但是要获取执行时间，线程本身没有什么办法）。Java使用的线程调度方式是抢占式调度。

线程的状态转换

* 新建New：创建后尚未启动的线程处于这种状态。
* 运行Runnable：包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。
* 无限期等待Waiting：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显式地唤醒。
  * 没有设置Timeout参数的Object.wait()
  * 没有设置Timeout参数的Thread.join()
  * LockSupport.park()
* 无限期等待Timed Waiting：处于这种状态的线程也不会被分配CPU执行时间，不过无须等待被其他线程显式地唤醒，在一定时间后它们会被系统自动唤醒。
  * Thread.sleep()
  * 设置了Timeout参数的Object.wait()
  * 设置了Timeout参数的Thread.join()
  * LockSupport.parkNanos()
  * LockSupport.parkUntil()
* 阻塞Blocked：线程被阻塞了，“阻塞状态”和“等待状态”的区别：阻塞是在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而等待则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。
* 结束Terminated：已终止线程的线程状态，线程已经结束执行。