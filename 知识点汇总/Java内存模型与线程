## 1.Java内存模型

​		主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和内存中取出变量这样的底层细节。Java内存模型规定所有的变量都存储在主内存，每条线程都有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中今夕，而不能直接读取主内存中的变量。

* 内存间交互操作
  * lock锁定
  * unlock解锁
  * read读取
  * load载入
  * use使用
  * assign赋值
  * store存储
  * write写入
* 对于volitile型变量的特殊规则：原理-volatile修饰的共享变量在进行写操作的时候会多一行汇编代码，luck前缀指令在多核处理器下引发两件事情：将当前处理器缓存行的数据写回到系统内存（声言该信号期间，处理器可以独占使用任何共享内存，锁总线，其他CPU不能访问总线）；这个写回内存的操作会引起其他CPU里缓存了该内存地址的数据无效（缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己的缓存的值是否过期，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置为无效状态。 MESI（修改，独占，共享，无效）控制协议去维护内部缓存和其他处理器缓存的一致性。在多核处理器系统中进行操作的时候，IA-32 和 Intel 64 处理器能嗅探其他处理器访问系统内存和它们的内部缓存。它们使用嗅探技术保证它的内部缓存，系统内存和其他处理器的缓存的数据在总线上保持一致。）。
  * 特性1：保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。由于volatile变量只能保证可见性，我们可能需要通过加锁来保证原子性。
  * 特性2：禁止指令重排序优化。（指令重排序是指CPU采用了允许将多条指令不安程序规定的顺序分开发送给各相应电路管理单元处理）
* happens-before先行发生原则：Java内存模型中定义的两项操作之间的偏序关系。Java内存模型下一些“天然的”先行发生关系，这些无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。
  * 程序次序规则：在一个线程内，安装程序代码顺序，书写在前的操作先行发生于书写在后面的操作（准确的说是控制流顺序而不是代码顺序）。
  * 管程锁定规则：一个unlock操作先行发生于后面（时间上的顺序）对同一个锁的lock操作。
  * volatile变量规则：对同一个volatile变量的写操作先行发生于后面（时间上的顺序）对这个变量的读操作。
  * 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。
  * 线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，可以通过join()方法结束和isAlive()的返回值等手段检测到线程已经终止执行。
  * 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过interrupted()方法检测到是否有中断发生。
  * 对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法。
  * 传递性：如果操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C。

## 2.线程